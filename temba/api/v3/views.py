from __future__ import absolute_import, unicode_literals

from django.contrib.auth import authenticate, login
from django.http import HttpResponse, JsonResponse
from django.db.models import Prefetch

from temba.api.models import APIToken, api_token
from temba.api.v1.views import ContactEndpoint as ContactEndpointV1, FlowStepEndpoint as FlowStepEndpointV1
from temba.api.v2.views import AuthenticateView as AuthenticateEndpointV2, BaseAPIView, ListAPIMixin, RunsEndpoint as RunsEndpointV2
from temba.contacts.models import Contact
from temba.flows.models import Flow, FlowStart, FlowStep, RuleSet
from temba.orgs.models import get_user_orgs
from temba.utils import str_to_bool

from .serializers import FlowRunReadSerializer


class AuthenticateView(AuthenticateEndpointV2):

    def form_valid(self, form, *args, **kwargs):
        username = form.cleaned_data.get('username')
        password = form.cleaned_data.get('password')
        role_code = form.cleaned_data.get('role')

        user = authenticate(username=username, password=password)
        if user and user.is_active:
            login(self.request, user)

            role = APIToken.get_role_from_code(role_code)

            if role:
                token = api_token(user)
                return JsonResponse(dict(token=token), safe=False)
            else:  # pragma: needs cover
                return HttpResponse(status=403)
        else:  # pragma: needs cover
            return HttpResponse(status=403)


class UserOrgsEndpoint(BaseAPIView, ListAPIMixin):
    """
    Provides the user's organizations and API tokens to use on Surveyor App
    """

    permission = 'orgs.org_api'

    def list(self, request, *args, **kwargs):
        user = request.user
        user_orgs = get_user_orgs(user)
        orgs = []

        role = APIToken.get_role_from_code('S')

        if role:
            for org in user_orgs:
                token = APIToken.get_or_create(org, user, role)
                orgs.append({'org': {'id': org.pk, 'name': org.name}, 'token': token.key})

        else:  # pragma: needs cover
            return HttpResponse(status=403)

        return JsonResponse({'orgs': orgs})


class ContactEndpoint(ContactEndpointV1):
    permission = 'contacts.contact_api'


class FlowStepEndpoint(FlowStepEndpointV1):
    permission = 'flows.flow_api'


class RunsEndpoint(RunsEndpointV2):
    """
    This endpoint allows you to fetch flow runs. A run represents a single contact's path through a flow and is created
    each time a contact is started in a flow.

    ## Listing Flow Runs

    A `GET` request returns the flow runs for your organization, filtering them as needed. Each
    run has the following attributes:

     * **id** - the ID of the run (int), filterable as `id`.
     * **flow** - the UUID and name of the flow (object), filterable as `flow` with UUID.
     * **contact** - the UUID and name of the contact (object), filterable as `contact` with UUID.
     * **submitted_by** - the first name and last name of the user that submitted (object), filterable as `submitted_by`.
     * **responded** - whether the contact responded (boolean), filterable as `responded`.
     * **path** - the contact's path through the flow nodes (array of objects)
     * **values** - values generated by rulesets in the flow (array of objects).
     * **created_on** - the datetime when this run was started (datetime).
     * **modified_on** - when this run was last modified (datetime), filterable as `before` and `after`.
     * **exited_on** - the datetime when this run exited or null if it is still active (datetime).
     * **exit_type** - how the run ended (one of "interrupted", "completed", "expired").

    Note that you cannot filter by `flow` and `contact` at the same time.

    Example:

        GET /api/v3/runs.json?flow=f5901b62-ba76-4003-9c62-72fdacc1b7b7

    Response is the list of runs on the flow, most recently modified first:

        {
            "next": "http://example.com/api/v3/runs.json?cursor=cD0yMDE1LTExLTExKzExJTNBM40NjQlMkIwMCUzRv",
            "previous": null,
            "results": [
            {
                "id": 12345678,
                "flow": {"uuid": "f5901b62-ba76-4003-9c62-72fdacc1b7b7", "name": "Favorite Color"},
                "contact": {"uuid": "d33e9ad5-5c35-414c-abd4-e7451c69ff1d", "name": "Bob McFlow"},
                "responded": true,
                "path": [
                    {"node": "27a86a1b-6cc4-4ae3-b73d-89650966a82f", "time": "2015-11-11T13:05:50.457742Z"},
                    {"node": "fc32aeb0-ac3e-42a8-9ea7-10248fdf52a1", "time": "2015-11-11T13:03:51.635662Z"},
                    {"node": "93a624ad-5440-415e-b49f-17bf42754acb", "time": "2015-11-11T13:03:52.532151Z"},
                    {"node": "4c9cb68d-474f-4b9a-b65e-c2aa593a3466", "time": "2015-11-11T13:05:57.576056Z"}
                ],
                "values": {
                    "color": {
                        "value": "blue",
                        "category": "Blue",
                        "node": "fc32aeb0-ac3e-42a8-9ea7-10248fdf52a1",
                        "time": "2015-11-11T13:03:51.635662Z"
                    },
                    "reason": {
                        "value": "Because it's the color of sky",
                        "category": "All Responses",
                        "node": "4c9cb68d-474f-4b9a-b65e-c2aa593a3466",
                        "time": "2015-11-11T13:05:57.576056Z"
                    }
                },
                "created_on": "2015-11-11T13:05:57.457742Z",
                "modified_on": "2015-11-11T13:05:57.576056Z",
                "exited_on": "2015-11-11T13:05:57.576056Z",
                "exit_type": "completed"
            },
            ...
        }
    """
    serializer_class = FlowRunReadSerializer

    def filter_queryset(self, queryset):
        params = self.request.query_params
        org = self.request.user.get_org()

        # filter by flow (optional)
        flow_uuid = params.get('flow')
        if flow_uuid:
            flow = Flow.objects.filter(org=org, uuid=flow_uuid, is_active=True).first()
            if flow:
                queryset = queryset.filter(flow=flow)
            else:
                queryset = queryset.filter(pk=-1)

        # filter by id (optional)
        run_id = self.get_int_param('id')
        if run_id:
            queryset = queryset.filter(id=run_id)

        # filter by submitted_by (optional)
        submitted_by = self.get_int_param('submitted_by')
        if submitted_by:
            queryset = queryset.filter(submitted_by=submitted_by)

        # filter by contact (optional)
        contact_uuid = params.get('contact')
        if contact_uuid:
            contact = Contact.objects.filter(org=org, is_test=False, is_active=True, uuid=contact_uuid).first()
            if contact:
                queryset = queryset.filter(contact=contact)
            else:
                queryset = queryset.filter(pk=-1)
        else:
            # otherwise filter out test contact runs
            test_contact_ids = list(Contact.objects.filter(org=org, is_test=True).values_list('pk', flat=True))
            queryset = queryset.exclude(contact__pk__in=test_contact_ids)

        # limit to responded runs (optional)
        if str_to_bool(params.get('responded')):
            queryset = queryset.filter(responded=True)

        # use prefetch rather than select_related for foreign keys to avoid joins
        queryset = queryset.prefetch_related(
            Prefetch('flow', queryset=Flow.objects.only('uuid', 'name', 'base_language')),
            Prefetch('contact', queryset=Contact.objects.only('uuid', 'name', 'language')),
            Prefetch('start', queryset=FlowStart.objects.only('uuid')),
            Prefetch('values'),
            Prefetch('values__ruleset', queryset=RuleSet.objects.only('uuid', 'label')),
            Prefetch('steps', queryset=FlowStep.objects.only('run', 'step_uuid', 'arrived_on').order_by('arrived_on'))
        )

        return self.filter_before_after(queryset, 'modified_on')
